"""
LUXBIN Token (LUX)

Native cryptocurrency for the LUXBIN Quantum Internet.

Blocks produce tokens as they store digital space:
- Mirrored blockchains = value
- Mirrored web pages = value
- Quantum operations = value

Token Economics:
- Total Supply: Generated by blocks (inflationary based on data stored)
- Block Reward: Proportional to digital space utilized
- Use Cases: Pay for storage, bandwidth, quantum operations, lightworker services

Author: Nichole Christie
Created: 2026
"""

from typing import Dict, List, Optional
from dataclasses import dataclass
import time


@dataclass
class LUXBINToken:
    """LUXBIN Token (LUX) - Native currency of quantum internet."""
    symbol: str = "LUX"
    name: str = "LUXBIN Token"
    decimals: int = 18
    total_supply: float = 0.0

    # Token distribution
    circulating_supply: float = 0.0
    staked_supply: float = 0.0

    # Reward rates
    block_base_reward: float = 10.0  # Base LUX per block
    storage_reward_rate: float = 0.001  # LUX per byte stored
    quantum_operation_reward: float = 5.0  # LUX per quantum operation
    mirror_reward: float = 1.0  # LUX per mirrored page/block


class LUXBINTokenomics:
    """
    Manages token economics for the living blockchain.
    """

    def __init__(self):
        self.token = LUXBINToken()
        self.balances: Dict[str, float] = {}
        self.rewards_history: List[Dict] = []

        print(f"ðŸ’° {self.token.name} ({self.token.symbol}) initialized")
        print(f"   Total supply: {self.token.total_supply:,.2f} LUX")
        print(f"   Block reward: {self.token.block_base_reward} LUX")

    def calculate_block_reward(
        self,
        num_chains_mirrored: int,
        num_pages_mirrored: int,
        num_quantum_ops: int,
        total_bytes_stored: int
    ) -> float:
        """
        Calculate LUX tokens produced by a superposition block.

        Blocks produce tokens based on digital space utilized:
        - More mirrored data = more tokens
        - More quantum operations = more tokens

        Args:
            num_chains_mirrored: Number of blockchain mirrors
            num_pages_mirrored: Number of web pages mirrored
            num_quantum_ops: Number of quantum operations
            total_bytes_stored: Total bytes of data stored

        Returns:
            LUX tokens produced
        """
        reward = self.token.block_base_reward

        # Reward for mirrored blockchains
        reward += num_chains_mirrored * self.token.mirror_reward * 10  # 10x for blockchain mirrors

        # Reward for mirrored web pages
        reward += num_pages_mirrored * self.token.mirror_reward

        # Reward for quantum operations
        reward += num_quantum_ops * self.token.quantum_operation_reward

        # Reward for data storage
        reward += total_bytes_stored * self.token.storage_reward_rate

        return reward

    def mint_block_reward(
        self,
        block_producer: str,
        block_index: int,
        reward_amount: float
    ):
        """
        Mint LUX tokens for block production.

        Args:
            block_producer: Address of block producer
            block_index: Block number
            reward_amount: LUX to mint
        """
        # Mint tokens
        self.token.total_supply += reward_amount
        self.token.circulating_supply += reward_amount

        # Credit to producer
        if block_producer not in self.balances:
            self.balances[block_producer] = 0.0
        self.balances[block_producer] += reward_amount

        # Record reward
        self.rewards_history.append({
            'block': block_index,
            'recipient': block_producer,
            'amount': reward_amount,
            'timestamp': time.time()
        })

        print(f"   ðŸ’° Minted {reward_amount:.2f} LUX â†’ {block_producer}")

    def transfer(self, from_addr: str, to_addr: str, amount: float) -> bool:
        """Transfer LUX tokens between addresses."""
        if from_addr not in self.balances or self.balances[from_addr] < amount:
            return False

        self.balances[from_addr] -= amount

        if to_addr not in self.balances:
            self.balances[to_addr] = 0.0
        self.balances[to_addr] += amount

        return True

    def stake(self, address: str, amount: float) -> bool:
        """Stake LUX tokens to become a lightworker."""
        if address not in self.balances or self.balances[address] < amount:
            return False

        self.balances[address] -= amount
        self.token.circulating_supply -= amount
        self.token.staked_supply += amount

        print(f"   ðŸ”’ Staked {amount:.2f} LUX from {address}")
        return True

    def get_statistics(self) -> Dict:
        """Get token statistics."""
        return {
            'symbol': self.token.symbol,
            'total_supply': self.token.total_supply,
            'circulating_supply': self.token.circulating_supply,
            'staked_supply': self.token.staked_supply,
            'total_holders': len(self.balances),
            'total_rewards_paid': sum(r['amount'] for r in self.rewards_history)
        }
